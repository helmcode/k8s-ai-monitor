from typing import Dict, Any
from slack_sdk import WebClient
from slack_sdk.errors import SlackApiError
from utils.logging import setup_logger

logger = setup_logger(__name__)

class SlackNotifier:
    def __init__(self, token, default_channel):
        self.client = WebClient(token=token)
        self.default_channel = default_channel

    def send_alert(self, issue: Dict[str, Any], diagnosis: str, recommendations: str, channel: str) -> bool:
        """
        Sends an alert about a Kubernetes issue

        Args:
            issue: Object with issue details
            diagnosis: Analysis generated by the LLM
            recommendations: Recommendations generated by the LLM
            channel: Slack channel

        Returns:
            bool: True if alert was sent successfully, False otherwise
        """
        if not channel:
            channel = self.default_channel

        try:
            # Prepare a more concise message
            severity = issue.get("severity", "Medium")
            severity_emoji = "üî¥" if severity == "High" else "üü†" if severity == "Medium" else "üü°"

            # Format the header with severity indicator and more context
            header_text = f"{severity_emoji} {issue['issue_type']}: {issue['resource_name']}"

            blocks = [
                {
                    "type": "header",
                    "text": {
                        "type": "plain_text",
                        "text": header_text,
                        "emoji": True
                    }
                },
                {
                    "type": "divider"
                },
                {
                    "type": "section",
                    "fields": [
                        {
                            "type": "mrkdwn",
                            "text": f"*üèóÔ∏è Cluster:*\n *{issue['cluster']}*"
                        },
                        {
                            "type": "mrkdwn",
                            "text": f"*üìç Namespace:*\n *{issue['namespace']}*"
                        }
                    ]
                },
                {
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": f"*üêû Issue:* *{issue.get('description', 'No description provided')}*"
                    }
                },
                {
                    "type": "divider"
                },
                {
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": f"*ü§ñ AI Diagnosis:*\n{diagnosis}"
                    }
                }
            ]

            if recommendations:
                blocks.append({
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": f"*AI Recommendations:*\n{recommendations}"
                    }
                })

            # Add a small excerpt of logs if available
            if "logs" in issue and issue["logs"]:
                # Take only the last 3 lines to avoid saturation
                if isinstance(issue["logs"], str):
                    logs = issue["logs"].strip().split("\n")[-3:]
                    log_text = "\n".join(logs)

                    # Show logs in a collapsed section to save space
                    blocks.append({
                        "type": "section",
                        "text": {
                            "type": "mrkdwn",
                            "text": f"*Recent Logs:*\n```{log_text}```"
                        }
                    })

            # Add a link to view more details (if you have a dashboard or UI)
            blocks.append({
                "type": "context",
                "elements": [
                    {
                        "type": "mrkdwn",
                        "text": f"Detected at: {issue['detected_at']}"
                    }
                ]
            })

            # Send message to Slack
            response = self.client.chat_postMessage(
                channel=channel,
                text=f"Kubernetes Alert: {issue['issue_type']} in {issue['resource_name']}",
                blocks=blocks
            )
            logger.info(f"Alert sent to Slack: {response['ts']}")
            return True

        except SlackApiError as e:
            logger.error(f"Error sending alert to Slack: {str(e)}")
            return False
